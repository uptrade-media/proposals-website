// ============================================================================
// DEPRECATED: This function is now redundant - use Signal API directly
// ============================================================================
// Portal now calls Signal API (NestJS) instead of internal Signal implementation.
// This function remains for backward compatibility but should not be used in new code.
//
// Migration:
//   Old: /.netlify/functions/signal-xxx
//   New: Signal API endpoints (see SIGNAL-API-MIGRATION.md)
//
// Signal API Base URL: $SIGNAL_API_URL (http://localhost:3001 or https://signal-api.uptrademedia.com)
// ============================================================================


// netlify/functions/signal-faqs.js
// Signal Module: FAQ management - auto-generated and manual FAQs
// Includes approval workflow for AI-suggested FAQs

import { createSupabaseAdmin, getAuthenticatedUser } from './utils/supabase.js'

const CORS_HEADERS = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'Content-Type, Authorization, X-Organization-Id, X-Project-Id',
  'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
  'Content-Type': 'application/json'
}

export async function handler(event) {
  if (event.httpMethod === 'OPTIONS') {
    return { statusCode: 204, headers: CORS_HEADERS }
  }

  const { contact, error: authError } = await getAuthenticatedUser(event)
  
  if (authError || !contact) {
    return {
      statusCode: 401,
      headers: CORS_HEADERS,
      body: JSON.stringify({ error: 'Not authenticated' })
    }
  }

  const supabase = createSupabaseAdmin()
  const projectId = event.queryStringParameters?.projectId || 
                   JSON.parse(event.body || '{}').projectId
  const faqId = event.queryStringParameters?.id

  // Special actions
  const action = event.queryStringParameters?.action

  if (!projectId && event.httpMethod !== 'DELETE' && !action) {
    return {
      statusCode: 400,
      headers: CORS_HEADERS,
      body: JSON.stringify({ error: 'Project ID is required' })
    }
  }

  try {
    // GET - List FAQs with filtering
    if (event.httpMethod === 'GET') {
      const { status, category, autoGenerated, page = 1, limit = 50 } = event.queryStringParameters || {}
      
      let query = supabase
        .from('signal_faqs')
        .select('*', { count: 'exact' })
        .eq('project_id', projectId)
        .order('priority', { ascending: false })
        .order('times_used', { ascending: false })

      if (status) {
        query = query.eq('status', status)
      }
      if (category) {
        query = query.eq('category', category)
      }
      if (autoGenerated !== undefined) {
        query = query.eq('is_auto_generated', autoGenerated === 'true')
      }

      const offset = (parseInt(page) - 1) * parseInt(limit)
      query = query.range(offset, offset + parseInt(limit) - 1)

      const { data: faqs, error, count } = await query

      if (error) throw error

      // Get stats
      const { data: stats } = await supabase
        .from('signal_faqs')
        .select('status, is_auto_generated')
        .eq('project_id', projectId)

      const statusCounts = stats?.reduce((acc, faq) => {
        acc[faq.status] = (acc[faq.status] || 0) + 1
        if (faq.is_auto_generated) acc.autoGenerated = (acc.autoGenerated || 0) + 1
        return acc
      }, { pending: 0, approved: 0, rejected: 0, archived: 0, autoGenerated: 0 }) || {}

      return {
        statusCode: 200,
        headers: CORS_HEADERS,
        body: JSON.stringify({
          faqs,
          pagination: {
            page: parseInt(page),
            limit: parseInt(limit),
            total: count,
            pages: Math.ceil(count / parseInt(limit))
          },
          stats: statusCounts
        })
      }
    }

    // POST - Create FAQ or perform action
    if (event.httpMethod === 'POST') {
      // Handle approval/rejection actions
      if (action === 'approve' && faqId) {
        const { data: faq, error } = await supabase
          .from('signal_faqs')
          .update({
            status: 'approved',
            approved_by: contact.id,
            approved_at: new Date().toISOString(),
            updated_at: new Date().toISOString()
          })
          .eq('id', faqId)
          .select()
          .single()

        if (error) throw error

        return {
          statusCode: 200,
          headers: CORS_HEADERS,
          body: JSON.stringify({ faq, message: 'FAQ approved' })
        }
      }

      if (action === 'reject' && faqId) {
        const { data: faq, error } = await supabase
          .from('signal_faqs')
          .update({
            status: 'rejected',
            updated_at: new Date().toISOString()
          })
          .eq('id', faqId)
          .select()
          .single()

        if (error) throw error

        return {
          statusCode: 200,
          headers: CORS_HEADERS,
          body: JSON.stringify({ faq, message: 'FAQ rejected' })
        }
      }

      if (action === 'archive' && faqId) {
        const { data: faq, error } = await supabase
          .from('signal_faqs')
          .update({
            status: 'archived',
            updated_at: new Date().toISOString()
          })
          .eq('id', faqId)
          .select()
          .single()

        if (error) throw error

        return {
          statusCode: 200,
          headers: CORS_HEADERS,
          body: JSON.stringify({ faq, message: 'FAQ archived' })
        }
      }

      // Create new FAQ
      const body = JSON.parse(event.body || '{}')
      const { question, answer, category, tags = [], priority = 0 } = body

      if (!question || !answer) {
        return {
          statusCode: 400,
          headers: CORS_HEADERS,
          body: JSON.stringify({ error: 'Question and answer are required' })
        }
      }

      // Get project org_id
      const { data: project } = await supabase
        .from('projects')
        .select('org_id')
        .eq('id', projectId)
        .single()

      if (!project) {
        return {
          statusCode: 404,
          headers: CORS_HEADERS,
          body: JSON.stringify({ error: 'Project not found' })
        }
      }

      const { data: newFaq, error } = await supabase
        .from('signal_faqs')
        .insert({
          project_id: projectId,
          org_id: project.org_id,
          question,
          answer,
          category,
          tags,
          priority,
          is_auto_generated: false,
          status: 'approved', // Manual FAQs are auto-approved
          approved_by: contact.id,
          approved_at: new Date().toISOString()
        })
        .select()
        .single()

      if (error) throw error

      return {
        statusCode: 201,
        headers: CORS_HEADERS,
        body: JSON.stringify({ faq: newFaq })
      }
    }

    // PUT - Update FAQ
    if (event.httpMethod === 'PUT') {
      const body = JSON.parse(event.body || '{}')
      const { id, question, answer, category, tags, priority } = body

      if (!id) {
        return {
          statusCode: 400,
          headers: CORS_HEADERS,
          body: JSON.stringify({ error: 'FAQ ID is required' })
        }
      }

      const updates = { updated_at: new Date().toISOString() }
      
      if (question !== undefined) updates.question = question
      if (answer !== undefined) updates.answer = answer
      if (category !== undefined) updates.category = category
      if (tags !== undefined) updates.tags = tags
      if (priority !== undefined) updates.priority = priority

      const { data: updated, error } = await supabase
        .from('signal_faqs')
        .update(updates)
        .eq('id', id)
        .select()
        .single()

      if (error) throw error

      return {
        statusCode: 200,
        headers: CORS_HEADERS,
        body: JSON.stringify({ faq: updated })
      }
    }

    // DELETE - Remove FAQ
    if (event.httpMethod === 'DELETE') {
      const id = event.queryStringParameters?.id || faqId

      if (!id) {
        return {
          statusCode: 400,
          headers: CORS_HEADERS,
          body: JSON.stringify({ error: 'FAQ ID is required' })
        }
      }

      const { error } = await supabase
        .from('signal_faqs')
        .delete()
        .eq('id', id)

      if (error) throw error

      return {
        statusCode: 200,
        headers: CORS_HEADERS,
        body: JSON.stringify({ success: true })
      }
    }

    return {
      statusCode: 405,
      headers: CORS_HEADERS,
      body: JSON.stringify({ error: 'Method not allowed' })
    }

  } catch (error) {
    console.error('Signal FAQs error:', error)
    return {
      statusCode: 500,
      headers: CORS_HEADERS,
      body: JSON.stringify({ error: error.message })
    }
  }
}
